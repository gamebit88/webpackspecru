<!DOCTYPE html>
<html>
<head>
	<title>Concepts</title>
		<style type="text/css">
		textarea{width:700px;height: 150px}
	</style>
</head>
<body>
<h1>Идея</h1>
<p>Webpack связывает модули для современных JS приложений. Все настраиваемо, однако нужно в этом увидеть 4е основных концепций прежде чем начать.</p>
<p>В рамках этого туторила мы написали этот документ, чтобы дать вам обзор этих концепций на высоком уровне, в то же время представляя ссылки на конкретные случаи использования.</p>
<p><h3>Entry</h3></p>
<p>Webpack создает графы всез зависимостей вашего приложения. Начальная точка этого графа называется точкой входа. Точка входа сообщает w где начинать и следовать графу зависимостей, что бы знать что нужно связать. Вы можете представить точку входа вашего приложения в качестве контекстного корневого или первого файла для запуска вашего приложения.</p>
<p>В w мы определяем точки входа, используя свойство entry в нашем <a href="config">объекте конфигурации w.</a></p>
<p>Простой пример ниже</p>
<p>webpack.config.js</p>
<p><textarea>module.exports = {
  entry: './path/to/my/entry/file.js'
};
</textarea></p>
<p>Есть несколько способов объявить ваше свойство entry, котороей зависит от потребностей вашего приложения.</p>
<p><a href="">Узнать больше</a></p>
<p><h3>Output</h3></p>
<p>Когда вы объедините все свои активы вместе, вам все равно нужно будет сообщить w куда нужно связать ваше приложение. Свойства вывода output сообщает w, как обрабатывать вложенный код.</p>
<p>wepback.config.js</p>
<p><textarea>const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};
</textarea></p>
<p>Выше в примере мы используем output.filename и output.path свойства указывая w имя файла нашей сборки и место куда его положить.</p>
<p>Вы можете увидеть термин emitted или emit в нашей документации и api плагинов. Это термин для выпущенного или выгруженного.</p>
<p>Свойство output имеет много настроек, но об этом можно узнать больше <a href="">тут</a>.</p>
<p><h3>Loaders</h3></p>
<p>Цель состоит в том, чтобы все активы в вашем проекте относились к w, а не к браузеру</p>
<p>Загрузчики в w преобразуют эти файлы в модули по мере их добавления в граф зависимостей.</p>
<p><ol>На высоком уровне у них есть 2е цели в вашей конфигурации w.
<li>Определите какие файлы должны быть преобразованы определенным загрузчиком(свойство test)</li>
<li>Преобразуйте этот файл, что бы он смог быть добавлен в граф зависимостей(и в конечном счете в ваш пакет)(свойство use)</li>
</ol></p>
<p>webpack.config.js</p>
<p><textarea>
	const path = require('path');

const config = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      {test: /\.(js|jsx)$/, use: 'babel-loader'}
    ]
  }
};

module.exports = config;

</textarea></p>
<p>Вышеописанная конфигурация определила свойство rules, для одного модуля с двуия обязательными свойствами test use. Это сообщает компилятору w следующее</p>
<p>Эай компилятор w, когда вы сталкиваетесь с путем, который разрешает файл js или jsx внутри оператора require()/import используйте babel загрузчик, чтобы преобразовать прежде чем добавлять его в пакет</p>
<p>Важно помнить что при определении правил вашей конфигурации w вы определяете их в модуле mokule.rules, а не в вправилах. Однако w будет кричать на вас, когда это делается неправильно.</p>
<p>Есть более конкретные свойства для определения на загрузчиках, которые мы еще не <a href="">рассмотрели.</a></p>
<p><h3>Plugins</h3></p>
<p>Поскольку загрузчики выполняют только преобразования на основе отдельного файла, плагины чаще всего используются (но не ограничиваются ими) для выполнения действий и специальных функций над «компиляциями» или «кусками» ваших вложенных модулей (и т. Д.).Плагин webpack очень мощный и настраиваемый.</p>
<p>Чтобы использовать плагин, вам нужно просто require () его и добавить его в массив плагинов.</p>
<p>Большинство плагинов настраиваются с помощью опций. Поскольку вы можете использовать плагин несколько раз в конфигурации для разных целей, вам нужно создать экземпляр, вызвав его с новым.</p>
<p>webpack.config.js</p>
<p><textarea>const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins
const path = require('path');

const config = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      {test: /\.(js|jsx)$/, use: 'babel-loader'}
    ]
  },
  plugins: [
    new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};

module.exports = config;
</textarea></p>
<p>Есть много плагинов, которые webpack предоставляет из коробки! Ознакомьтесь с нашим списком плагинов для получения дополнительной информации.</p>
<p>Использование плагинов в вашей конфигурации webpack прямолинейно, однако есть много прецедентов, которые стоит обсудить <a href="">дальше.</a></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</body>
</html>