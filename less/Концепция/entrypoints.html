<!DOCTYPE html>
<html>
<head>
	<title>entry points</title>
		<style type="text/css">
		textarea{width:700px;height: 150px}
	</style>
</head>
<body>
<h1>Entry points</h1>
<p>Как мы уже упоминали во введении, существует несколько способов определения свойства записи в конфигурации вашего webpack. Мы покажем вам, как вы можете настроить свойство записи, а также объяснить, почему это может быть полезно для вас.</p>
<p><h3>Single Entry (Shorthand) Syntax</h3></p>
<p>entry: string|Array string</p>
<p>webpack.config.js</p>
<p><textarea>const config = {
  entry: './path/to/my/entry/file.js'
};

module.exports = config;
</textarea></p>
<p>Синтаксис одиночной записи для свойства entry является сокращением для:</p>
<p><textarea>const config = {
  entry: {
    main: './path/to/my/entry/file.js'
  }
};
</textarea></p>
<p>Что происходит, когда вы передаете массив в entry? Передача массива путей к свойству entry создает так называемую «многоканальную запись». Это полезно, если вы хотите вставить несколько зависимых файлов вместе и поместить их зависимости в один «кусок».</p>
<p>Это отличный выбор, если вы хотите быстро настроить конфигурацию webpack для приложения или инструмента с одной точкой входа (IE: библиотека). Тем не менее, гибкость в расширении или масштабировании конфигурации с помощью этого синтаксиса невелика.</p>
<p><h3>Object Syntax</h3></p>
<p>Использование: entry: {[entryChunkName: string]: string|Arraystring}</p>
<p>webpack.config.js</p>
<p><textarea>const config = {
  entry: {
    app: './src/app.js',
    vendors: './src/vendors.js'
  }
};
</textarea></p>
<p>Синтаксис объекта более подробный. Тем не менее, это самый масштабируемый способ определения entry/entries в вашем приложении.</p>
<p>«Масштабируемые конфигурации webpack» - это те, которые могут быть повторно использованы и объединены с другими частичными конфигурациями. Это популярный метод, используемый для разделения проблем по окружению, построения целевого объекта и времени выполнения. Затем они объединяются с помощью специализированных инструментов, таких как webpack-merge.</p>
<p><h3>Scenarios</h3></p>
<p>Ниже приведен список конфигураций записей и их реальных случаев использования:</p>
<p><h4>Separate App and Vendor Entries</h4></p>
<p>webpack.config.js</p>
<p><textarea>const config = {
  entry: {
    app: './src/app.js',
    vendors: './src/vendors.js'
  }
};
</textarea></p>
<p>Что это значит? По номиналу это указывает webpack на создание графов зависимостей, начинающихся как с app.js, так и с vendors.js. Эти графики полностью независимы и независимы друг от друга (в каждом пакете будет загружаться webpack). Это обычно наблюдается в одностраничных приложениях, у которых есть только одна точка входа (за исключением поставщиков).</p>
<p>Зачем? Эта настройка позволяет вам использовать CommonsChunkPlugin и извлекать любые ссылки от вашего пакета приложений в ваш комплект вендора, заменяя их вызовами __webpack_require __ (). Если в комплекте приложений нет кода поставщика, вы можете достичь общей модели в webpack, известной как долгосрочное кэширование поставщиков.</p>
<p>Рассмотрите возможность удаления этого сценария в пользу DllPlugin, который обеспечивает лучшее разделение поставщиков.</p>
<p><h4>Multi Page Application</h4></p>
<p>webpack.config.js</p>
<p><textarea>const config = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
</textarea></p>
<p>Что это значит? Мы сообщаем webpack, что нам нужно 3 отдельных графа зависимостей (как в примере выше).</p>
<p>Зачем? В многостраничном приложении сервер собирается получить новый документ HTML для вас. Страница перезагружает этот новый документ, а активы повторно загружаются. Тем не менее, это дает нам уникальную возможность сделать несколько вещей:</p>
<p>Используйте CommonsChunkPlugin для создания пакетов совместного кода приложения между каждой страницей. Многостраничные приложения, которые используют много кода / модулей между точками ввода, могут значительно выиграть от этих методов, так как количество точек входа увеличивается.</p>
<p>Как правило: для каждого документа HTML используется ровно одна точка входа.</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</body>
</html>